# Migration `20200922125123-init`

This migration has been generated by Rahul Sethuram at 9/22/2020, 2:51:23 PM.
You can check out the [state of the schema](./schema.prisma) after the migration.

## Database Steps

```sql
CREATE TABLE "balance" (
    "participant" TEXT NOT NULL,
    "assetId" TEXT NOT NULL,
    "to" TEXT NOT NULL,
    "amount" TEXT NOT NULL,
    "lockedBalance" TEXT NOT NULL,
    "channelAddress" TEXT NOT NULL,

    FOREIGN KEY ("channelAddress") REFERENCES "channel"("channelAddress") ON DELETE CASCADE ON UPDATE CASCADE,
PRIMARY KEY ("participant","channelAddress","assetId")
)

CREATE TABLE "channel" (
    "channelAddress" TEXT NOT NULL,
    "publicIdentifierA" TEXT NOT NULL,
    "publicIdentifierB" TEXT NOT NULL,
    "participantA" TEXT NOT NULL,
    "participantB" TEXT NOT NULL,
    "assetIds" TEXT NOT NULL,
    "timeout" TEXT NOT NULL,
    "nonce" INTEGER NOT NULL,
    "latestDepositNonce" INTEGER NOT NULL,
    "merkleRoot" TEXT NOT NULL,
    "channelFactoryAddress" TEXT NOT NULL,
    "channelMastercopyAddress" TEXT NOT NULL,
    "chainId" INTEGER NOT NULL,
    "providerUrl" TEXT NOT NULL,
PRIMARY KEY ("channelAddress")
)

CREATE TABLE "update" (
    "channelAddress" TEXT,
    "channelAddressId" TEXT NOT NULL,
    "fromIdentifier" TEXT NOT NULL,
    "toIdentifier" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "nonce" INTEGER NOT NULL,
    "amountA" TEXT NOT NULL,
    "amountB" TEXT NOT NULL,
    "toA" TEXT NOT NULL,
    "toB" TEXT NOT NULL,
    "assetId" TEXT NOT NULL,
    "signatureA" TEXT,
    "signatureB" TEXT,
    "transferId" TEXT,
    "transferDefinition" TEXT,
    "transferTimeout" TEXT,
    "transferInitialState" TEXT,
    "transferEncodings" TEXT,
    "merkleProofData" TEXT,
    "meta" TEXT,
    "transferResolver" TEXT,
    "merkleRoot" TEXT,
    "latestDepositNonce" INTEGER,

    FOREIGN KEY ("channelAddress") REFERENCES "channel"("channelAddress") ON DELETE SET NULL ON UPDATE CASCADE,
PRIMARY KEY ("channelAddressId","nonce")
)

CREATE TABLE "transfer" (
    "routingId" TEXT NOT NULL,
    "initialAmountA" TEXT NOT NULL,
    "initialAmountB" TEXT NOT NULL,
    "initialToA" TEXT NOT NULL,
    "initialToB" TEXT NOT NULL,
    "initialStateHash" TEXT NOT NULL,
    "createUpdateChannelAddressId" TEXT NOT NULL,
    "createUpdateNonce" INTEGER NOT NULL,
    "resolveUpdateChannelAddressId" TEXT,
    "resolveUpdateNonce" INTEGER,

    FOREIGN KEY ("createUpdateChannelAddressId","createUpdateNonce") REFERENCES "update"("channelAddressId","nonce") ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY ("resolveUpdateChannelAddressId","resolveUpdateNonce") REFERENCES "update"("channelAddressId","nonce") ON DELETE SET NULL ON UPDATE CASCADE,
PRIMARY KEY ("routingId")
)

CREATE UNIQUE INDEX "channel.publicIdentifierA_publicIdentifierB_chainId_unique" ON "channel"("publicIdentifierA", "publicIdentifierB", "chainId")

CREATE UNIQUE INDEX "channel.participantA_participantB_chainId_unique" ON "channel"("participantA", "participantB", "chainId")

CREATE UNIQUE INDEX "update_channelAddress_unique" ON "update"("channelAddress")

CREATE UNIQUE INDEX "transfer_createUpdateChannelAddressId_createUpdateNonce_unique" ON "transfer"("createUpdateChannelAddressId", "createUpdateNonce")

CREATE UNIQUE INDEX "transfer_resolveUpdateChannelAddressId_resolveUpdateNonce_unique" ON "transfer"("resolveUpdateChannelAddressId", "resolveUpdateNonce")
```

## Changes

```diff
diff --git schema.prisma schema.prisma
migration ..20200922125123-init
--- datamodel.dml
+++ datamodel.dml
@@ -1,0 +1,116 @@
+generator client {
+  provider        = "prisma-client-js"
+  previewFeatures = ["connectOrCreate"]
+  binaryTargets   = ["native"]
+}
+
+datasource db {
+  provider = ["postgresql", "sqlite"]
+  url = "***"
+}
+
+model Balance {
+  @@map(name: "balance")
+  participant    String
+  assetId        String
+  to             String
+  amount         String
+  lockedBalance  String
+  Channel        Channel @relation(fields: [channelAddress], references: [channelAddress])
+  channelAddress String
+  @@id([participant, channelAddress, assetId])
+}
+
+model Channel {
+  @@map(name: "channel")
+  channelAddress                 String    @id
+  publicIdentifierA              String
+  publicIdentifierB              String
+  participantA                   String
+  participantB                   String
+  assetIds                       String
+  timeout                        String
+  nonce                          Int
+  latestDepositNonce             Int
+  merkleRoot                     String
+  balances                       Balance[]
+  channelFactoryAddress          String
+  channelMastercopyAddress String
+  chainId                        Int
+  providerUrl                    String
+  latestUpdate                   Update
+
+  @@unique([publicIdentifierA, publicIdentifierB, chainId])
+  @@unique([participantA, participantB, chainId])
+}
+
+model Update {
+  @@map(name: "update")
+  // COMMON PARAMS
+  channelAddress   String?
+  channel          Channel? @relation(fields: [channelAddress], references: [channelAddress])
+  channelAddressId String // required for ID so that relation can be removed
+
+  fromIdentifier String
+  toIdentifier   String
+  type           String
+  nonce          Int
+
+  // balance
+  amountA String
+  amountB String
+  toA     String
+  toB     String
+
+  assetId    String
+  signatureA String?
+  signatureB String?
+
+  // DETAILS
+  // create details
+  transferId           String?
+  transferDefinition   String?
+  transferTimeout      String?
+  transferInitialState String? // JSON string
+  transferEncodings    String?
+  merkleProofData      String? // proofs.join(",")
+  meta                 String?
+
+  // resolve details
+  transferResolver String?
+  merkleRoot       String?
+
+  // deposit details
+  latestDepositNonce Int?
+
+  // setup inferred from channel params
+
+  // transfers are linked to a separate model
+  createdTransfer  Transfer? @relation("CreatedTransfer")
+  resolvedTransfer Transfer? @relation("ResolvedTransfer")
+
+  @@id([channelAddressId, nonce])
+}
+
+model Transfer {
+  @@map(name: "transfer")
+  routingId     String  @id
+  createUpdate  Update  @relation(name: "CreatedTransfer", fields: [createUpdateChannelAddressId, createUpdateNonce], references: [channelAddressId, nonce])
+  resolveUpdate Update? @relation(name: "ResolvedTransfer", fields: [resolveUpdateChannelAddressId, resolveUpdateNonce], references: [channelAddressId, nonce])
+
+  // initial balance
+  initialAmountA String
+  initialAmountB String
+  initialToA     String
+  initialToB     String
+
+  initialStateHash String
+
+  // created will always exist
+  createUpdateChannelAddressId String
+  createUpdateNonce            Int
+
+  // resolved will not always exist
+  resolveUpdateChannelAddressId String?
+  resolveUpdateNonce            Int?
+}
```


